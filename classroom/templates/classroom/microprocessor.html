{% extends 'classroom/base.html' %}
{% block main %}
{% load static %}

<!-- INDEX STARTS HERE -->
<section class="main-section">
    <header class="INDEX" id="index">INDEX</header>
    <br>
    <article>
        <ul>
            <li><a href="#ch1"><h5> Chapter 1: 8086 Microprocessor </h5></a></li>
        <ol>
            <li><a href="#IMP">Introduction to Microprocessor</a></li>
            <li><a href="#BOC">Basic Organization of a Computer</a></li>
            <li><a href="#8086_sail_feat"> Salient Feature</a></li>
            <li><a href="#8086_arch_work">8086 Archiecture and Working</a></li>
            <li><a href="#8086_mem_segm">8086 Mermory Segmentation</a></li>
            <li><a href="#8086_mem_bank">8086 Memory Banking</a></li>
            <li><a href="#8086_pin_diag">8086 Pin Diagram</a> </li>
        </ol>
        <br>
        <li><h5><a href="#chap2">Chapter 2: 8086 Assembly Language</a> </h5></li>
        <ol>
            <li><a href="#8086_Addg_Modes"> 8086 Addressing Modes</a></li>
            <li><a href="#Data_mem_addrg_mode">Data Memory Addressing modes</a> </li>
            <li><a href="#i/o_addrg_modes">I/O addressing Modes of 8086</a></li>
            <li><a href="#addrg_mode_pgm_mem">Addressing Modes for Program Memory</a> </li>
            <li> <a href="#soft_mdl"> 8086 Software Model</a></li>
            <li><a href="#8086_intutn_set">8086 Insruction Set</a> </li>
            <li><a href="#dtinst">Data Transfer Instruction</a> </li>
            <li><a href="#arith_inst">Arithmetic Instruction</a> </li>
            <li><a href="#dec_adj_inst"> Decimal Adjust Instruction</a></li>
            <li><a href="#ascii_adj_inst"> ASCII Adjust Instruction</a></li>
            <li><a href="#log_inst">Logic Instruction(Bit Manipulation Instruction)</a></li>
            <li><a href="#shi_inst">Shift Instructions</a> </li>
            <li> <a href="#rte_inst"> Rotate Instructions</a></li>
            <li><a href="#brh_inst">Branch Instructions(Program Execution and Transfer)</a> </li>
            <li><a href="#itrn_ctl_inst">Iteration Control Instructions</a></li>
            <li><a href="#p/m_con_inst">Processor Control / Machine Control Instructions</a> </li>
            <li><a href="#exl_hwe_syn_inst">External Hardware Synchronization Instructions</a> </li>
            <li><a href="#itr_clt_inst">Interrupt Control Instructions</a> </li>
            <li><a href="#str_inst">String Instructions f 8086</a> </li>
            <li><a href="#inst_temp">8086 Instruction Template/Format</a> </li>
            <li><a href="#amlr_dir_psd_opcd"> 8086 Assembler Directive, Pseudo Opcodes</a></li>
        </ol>
        </ul>

                
        
        
       
    </article>

</section>
<!-- INDEX ENDS HERE -->
<br>

<!-- CHAPTER 1 STARTS HERE -->
<section class="main-section">
    <header id="ch1">Chapter 1: 8086 Microprocessor</header>
    <br>

    <!-- INTRODUCTION OF MICROPROCESSOR START -->
    <article>
        <h3 id="IMP">Introduction to Microprocessor</h3>
        <p>A Microprocessor is an important part of a computer architecture without which you will not be able to perform anything on your computer. It is a programmable device that takes in input performs some arithmetic and logical operations over it and produces the desired output. In simple words, a Microprocessor is a digital device on a chip that can fetch instructions from memory, decode and execute them and give results. </p>
        <b>Basics of Microprocessor – </b>
        <p>A Microprocessor takes a bunch of instructions in machine language and executes them, telling the processor what it has to do. Microprocessor performs three basic things while executing the instruction:</p>
        <ol>
            <li>It performs some basic operations like addition, subtraction, multiplication, division, and some logical operations using its Arithmetic and Logical Unit (ALU). New Microprocessors also perform operations on floating-point numbers also. </li>
            <li>Data in microprocessors can move from one location to another. </li>
            <li>It has a Program Counter (PC) register that stores the address of the next instruction based on the value of the PC, Microprocessor jumps from one location to another and takes decisions. </li>
        </ol>
    </article>
    <!-- INTRODUCTION OF MICROPROCESSOR ENDS -->
    <br>

    

    <!-- BASIC ORGANIZATIN OF A COMPUTER START -->
    <article>
        <h3 id="BOC">Basic Organization of a Computer</h3>
        <br>
        <p>Any computer can perform the four basic operations of Input, Processing, Output, and Storage (IPOS). These operations constitute the IPOS cycle. The internal design or structure of a computer may differ from one system to another though the basic operations remain the same. Figure 1.1 provides a block diagram of a computer. The figure displays all the functional units of a computer which carry out the basic computer operations. The lines in the figure indicate the flow of instructions and data, while the Control Unit and the Arithmetic/Logical Unit together direct the flow of control in the central processing unit.</p>
        <img src="{% static 'mp_img/ch1_boc1.png'%}" class="img-fluid" alt="">
        <ul>
            <li>
                <b>Microprocessor</b>
                <ol>
                    <li>ALU</li>
                    <ul>
                        <li>This unit executes all arithmetic and logical operations as specified by instruction set; and produces output</li>
                        <li>The results of addition, subtraction, and logical operations (AND, OR, XOR) are stored in the registers or in memory unit or sent to output unit.</li>
                    </ul>
                    <li>Register unit</li>
                    <ul>
                        <li>Consists of various registers.</li>
                        <li>Used for temporary storage of data during execution of data.</li>
                    </ul>
                    <li>CU</li>
                    <ul>
                        <li>Controls the operations of different instructions.</li>
                        <li>Provides necessary timing and control signals to all the operations in the MP and peripherals including memory.</li>
                    </ul>
                </ol>
            </li>
            <li>
                <b>Memory</b>
                <ol>
                    <li>Stores binary information such as instruction and data, and provide these information to MP when required.</li>
                    <li>To execute programs, the MP reads data and instructions from memory and performs the computing operations.</li>
                </ol>
            </li>
            <li>
                <b>System bus</b>
                <ul>
                    <li>The system bus is a communication path between MP and peripherals</li>
                    <li>It is used to carry data, address and control signals.</li>
                    <li>
                        It consists:
                        <p>Data bus: carries data</p>
                        <p>Address bus: carries address</p>
                        <p>Control bus: carries control signals</p>
                    </li>
                </ul>
            </li>
            <li>
                <b>I/O bus</b>
                <ul>
                    <li>Input unit is used to input instruction or data to the MP externally.</li>
                    <li>Output unit is used to carry out the information from the MP unit.</li>
                </ul>
            </li>
        </ul>
    </article>
    <!-- BASIC ORGANIZATIN OF A COMPUTER ENDS -->
    <br>

    <!-- SAILENT FEATURES START -->
    <article>
        <h3 id="8086_sail_feat">8086 Sailent Feature</h3>
        <br>
        <ol>
            <li>Single +5V power supply</li>
            <li>Clock speed range of 5-10MHz</li>
            <li>capable of executing about 0.33 MIPS (Millions instructions per second)</li>
            <li>It is 16-bit processor having 16-bit ALU, 16-bit registers, internal data bus, and 16-bit external data bus resulting in faster processing.</li>
            <li>It uses two stages of pipelining, i.e. Fetch Stage and Execute Stage, which improves performance.</li>
            <li>Fetch stage can prefetch up to 6 bytes of instructions and stores them in the queue.</li>
            <li>It has 256 interrupts.</li>
        </ol>
        <b>Architecture of 8086</b>
        <p>he following diagram depicts the architecture of a 8086 Microprocessor −</p>
        <img src="{% static 'mp_img/ch1_sail_feat1.png'%}" class="img-fluid" alt="">
        <p>8086 Microprocessor is divided into two functional units, i.e., EU (Execution Unit) and BIU (Bus Interface Unit).</p>
        <b>EU (Execution Unit</b><p>Execution unit gives instructions to BIU stating from where to fetch the data and then decode and execute those instructions. Its function is to control operations on data using the instruction decoder & ALU. EU has no direct connection with system buses as shown in the above figure, it performs operations over data through BIU.</p>
        <strong>functional parts of 8086 microprocessors.</strong>
        <ul>
            <li><b>ALU</b></li><p>It handles all arithmetic and logical operations, like +, −, ×, /, OR, AND, NOT operations.</p>
            <li><b>Flag Register</b></li><p>It is a 16-bit register that behaves like a flip-flop, i.e. it changes its status according to the result stored in the accumulator. It has 9 flags and they are divided into 2 groups − Conditional Flags and Control Flags.</p>
            <li>
                <b>BIU (Bus Interface Unit)</b>
                <p>BIU takes care of all data and addresses transfers on the buses for the EU like sending addresses, fetching instructions from the memory, reading data from the ports and the memory as well as writing data to the ports and the memory. EU has no direction connection with System Buses so this is possible with the BIU. EU and BIU are connected with the Internal Bus.</p>
                <p>It has the following functional parts </p>
                <ul>
                    <li><b>Instruction queue</b></li>
                    <p> BIU contains the instruction queue. BIU gets upto 6 bytes of next instructions and stores them in the instruction queue. When EU executes instructions and is ready for its next instruction, then it simply reads the instruction from this instruction queue resulting in increased execution speed.</p>
                    <p>Fetching the next instruction while the current instruction executes is called pipelining.</p>
                    <b><li>Segment register </li></b><p>BIU has 4 segment buses, i.e. CS, DS, SS& ES. It holds the addresses of instructions and data in memory, which are used by the processor to access memory locations. It also contains 1 pointer register IP, which holds the address of the next instruction to executed by the EU.</p>
                    <li><b>CS</b></li><p>It stands for Code Segment. It is used for addressing a memory location in the code segment of the memory, where the executable program is stored.</p>
                    <li><b>DS</b></li><p>It stands for Data Segment. It consists of data used by the program andis accessed in the data segment by an offset address or the content of other register that holds the offset address.</p>
                    <li><b>SS</b></li><p>It stands for Stack Segment. It handles memory to store data and addresses during execution.</p>
                    <li><b>ES</b></li><p>t stands for Extra Segment. ES is additional data segment, which is used by the string to hold the extra destination data.</p>
                    <li><b>Instruction pointer</b></li><p>It is a 16-bit register used to hold the address of the next instruction to be executed.</p>
                </ul>

            </li>
            <li>
                <b>Concept of Pipelining</b>
                <p>fetching the next instruction while the current instruction executes is known as pipelining to speed up program execution, the bus interface unit fatches as many as 6 instruction bytes ahead of time from the memory and these are held for execution unit in the (FIFO) group of registers called QUEUE.</p>
                <p>The BIU can fetch instruction byte while EU is decoding or executing an instruction which does not require the use of buses. When is EU is ready for the next instruction, it simply reads the instruction from queue in the BIU.</p>
                <p>the Queue is fellied when at least two bytes are empty as 8086 has a 16 bit data bus</p>
            </li>
        </ul>
    </article>
    <!-- SAILENT FEATURES END -->
    <br>

    <!-- 8086 ARCHITECTURE AND WORKING START -->
        <article>
            <h3 id="8086_arch_work">8086 Architecture and Working</h3>
            <br>
            <h5>Architecture of 8086</h5>
            <p>A Microprocessor is an Integrated Circuit with all the functions of a CPU however, it cannot be used stand alone since unlike a microcontroller it has no memory or peripherals. </p>
            <p>8086 does not have a RAM or ROM inside it. However, it has internal registers for storing intermediate and final results and interfaces with memory located outside it through the System Bus.</p>
            <p>In case of 8086, it is a 16-bit Integer processor in a 40 pin, Dual Inline Packaged IC. </p>
            <p>The size of the internal registers(present within the chip) indicate how much information the processor can operate on at a time (in this case 16-bit registers) and how it moves data around internally within the chip, sometimes also referred to as the internal data bus. </p>
            <p>8086 provides the programmer with 14 internal registers, each 16 bits or 2 Bytes wide. </p>
            <p>Memory segmentation: </p>
            <ul>
                <li>To increase execution speed and fetching speed, 8086 segments the memory. </li>
                <li>It’s 20 bit address bus can address 1MB of memory, it segments it into 16 64kB segments. </li>
                <li>8086 works only with four 64KB segments within the whole 1MB memory.</li>
            </ul>
            <p>The internal architecture of Intel 8086 is divided into 2 units: The Bus Interface Unit (BIU), and The Execution Unit (EU). These are explained as following below. </p>
            <ol>
                <li>
                    <b>The Bus Interface Unit (BIU):</b>
                    <p>It provides the interface of 8086 to external memory and I/O devices via the System Bus. It performs various machine cycles such as memory read, I/O read etc. to transfer data between memory and I/O devices. </p>
                    <p>BIU performs the following functions- </p>
                    <ul>
                        <li>It generates the 20 bit physical address for memory access.</li>
                        <li>It fetches instructions from the memory.</li>
                        <li>It transfers data to and from the memory and I/O.</li>
                        <li>Maintains the 6 byte prefetch instruction queue(supports pipelining).</li>
                    </ul>
                    <p>BIU mainly contains the 4 Segment registers, the Instruction Pointer, a prefetch queue and an Address Generation Circuit. </p>
                    <br>
                    <b>Instruction Pointer (IP): </b>
                    <ul>
                        <li>It is a 16 bit register. It holds offset of the next instructions in the Code Segment.</li>
                        <li>IP is incremented after every instruction byte is fetched.</li>
                        <li>IP gets a new value whenever a branch instruction occurs.</li>
                        <li>CS is multiplied by 10H to give the 20 bit physical address of the Code Segment.</li>
                        <li>Address of the next instruction is calculated as CS x 10H + IP.</li>
                    </ul>
                    <br>
                    <b>Example: </b>
                    <p class="note"> CS = 4321H TP = 1000H <br> then CS x10H = 43210H + offset = 210H</p>
                    <br>
                    <p>This is the address of the instruction. </p>
                    <p><b>Code Segment register: </b></p>
                    <p>CS holds the base address for the Code Segment. All programs are stored in the Code Segment and accessed via the IP. </p>
                    <p><b>Data Segment register: </b></p>
                    <p>DS holds the base address for the Data Segment</p>
                    <p><b>Stack Segment register: </b></p>
                    <p>SS holds the base address for the Stack Segment.</p>
                    <p><b>Extra Segment register: </b></p>
                    <p>ES holds the base address for the Extra Segment. </p>
                    <p><b>Address Generation Circuit:</b></p>
                    <ul>
                        <li>The BIU has a Physical Address Generation Circuit.</li>
                        <li>It generates the 20 bit physical address using Segment and Offset addresses using the formula: </li>
                        <p class="note">Physical Address = Segment Address x 10H + Offset Address</p>
                    </ul>
                    <b>6 Byte Pre-fetch Queue: </b>
                    <ul>
                        <li>It is a 6 byte queue (FIFO).</li>
                        <li>Fetching the next instruction (by BIU from CS) while executing the current instruction is called pipelining.</li>
                        <li>Gets flushed whenever a branch instruction occurs. </li>
                    </ul>
                </li>
                <li>
                    <b>The Execution Unit (EU):</b>
                    <p>The main components of the EU are General purpose registers, the ALU, Special purpose registers, Instruction Register and Instruction Decoder and the Flag/Status Register. </p>
                    <ol>
                        <li>Fetches instructions from the Queue in BIU, decodes and executes arithmetic and logic operations using the ALU.</li>
                        <li>Sends control signals for internal data transfer operations within the microprocessor.</li>
                        <li>Sends request signals to the BIU to access the external module.</li>
                        <li>It operates with respect to T-states (clock cycles) and not machine cycles.</li>
                    </ol>
                    <p>8086 has four 16 bit general purpose registers AX, BX, CX and DX. Store intermediate values during execution. Each of these have two 8 bit parts (higher and lower). </p>
                    <ul>
                        <li>AX register: </li>
                        <p>It holds operands and results during multiplication and division operations. Also an accumulator during String operations.</p>
                        <li>BX register: </li>
                        <p>It holds the memory address (offset address) in idirect addressing modes. </p>
                        <li>CX register: </li>
                        <p>It holds count for instructions like loop, rotate, shift and string operations. </p>
                        <li>DX register: </li>
                        <p>It is used with AX to hold 32 bit values during multiplication and division. </p>
                    </ul>
                    <b>Arithmetic Logic Unit (16 bit): </b>
                    <p>Performs 8 and 16 bit arithmetic and logic operations. </p>
                    <b>Special purpose registers (16-bit): </b>
                    <ul>
                        <li>Stack Pointer: </li><p>Points to Stack top. Stack is in Stack Segment, used during instructions like PUSH, POP, CALL, RET etc</p>
                        <li>Base Pointer: </li><p>BP can hold offset address of any location in the stack segment. It is used to access random locations of the stack.</p>
                        <li>Source Index: </li><p>It holds offset address in Data Segment during string operations.</p>
                        <li>Destination Index: </li><p>It holds offset address in Extra Segment during string operations.</p>
                    </ul>
                    <b>Instruction Register and Instruction Decoder: </b><p>The EU fetches an opcode from the queue into the instruction register. The instruction decoder decodes it and sends the information to the control circuit for execution. </p>
                    <b>Flag/Status register (16 bits): </b><p>It has 9 flags that help change or recognize the state of the microprocessor. </p>
                    <b>6 Status flags: </b>
                    <ol>
                        <li>carry flag(CF)</li>
                        <li>parity flag(PF)</li>
                        <li>auxiliary carry flag(AF)</li>
                        <li>zero flag(Z)</li>
                        <li>sign flag(S)</li>
                        <li>overflow flag (O)</li>
                        <p>Status flags are updated after every arithmetic and logic operation. </p>
                    </ol>
                </li>
                <li>
                    <b>3 Control flags: </b>
                    <ol>
                         <li>trap flag(TF)</li>
                         <li>interrupt flag(IF)</li>
                         <li>direction flag(DF)</li>
                    </ol>
                    <p>These flags can be set or reset using control instructions like CLC, STC, CLD, STD, CLI, STI, etc. </p>
                    <p>The Control flags are used to control certain operations.</p>
                </li>
            </ol>
            <br>
            <h5>Working of 8086</h5>
            <ol>
                <li>The BIU outputs the contents of the instruction pointer register (IP) onto the address bus, causing the selected byte or word to be read into the BIU</li>
                <li>Register IP is incremented by 1 to prepare for the next instruction fetch.</li>
                <li>Once inside the BIU, the instruction is passed to the queue</li>
                <li>Assuming that the queue is initially empty, the EU immediately draws this instruction from the queue and begins execution</li>
                <li>While the EU is executing this instruction, the BIU proceeds to fetch a new instruction. Depending on the execution time of the first instruction, the BIU may fill the queue with several new instructions before the EU is ready to draw its next instruction.</li>
            </ol>

            <p>The BIU is programmed to fetch a new instruction whenever the queue has room for two additional bytes. There are three conditions that will cause the EU to enter a “wait” mode or BIU to suspend fetching.</p>
            <ol>
                <p>The first one occurs when the instruction requires access to a memory location. Here the BIU must suspend fetching instructions and output the address of this memory location. Then the EU will resume execution.</p>
                <p>The second will occur when the instruction to be executed is a “jump” instruction. In this case control is to be transferred to a new non-sequential address.</p>
                <p>The third one will occur during the execution of an instruction that is slow to execute.For example, the instruction AAM (ASCII Adjust for Multiplication) requires 83 clock cycles to complete. At four cycles per instruction fetch, the queue will be completely filled during the execution of this single instruction.</p>
            </ol>
        </article>
    <!-- 8086 ARCHITECTURE AND WORKING END -->

    <br>

    <!-- 8086 MEMORY SEGMETATION START -->
    <article>
        <h3 id="8086_mem_segm">8086 Memory Segmentation</h3>
        <br>
        <p><b>Segmentation</b> is the process in which the main memory of the computer is logically divided into different segments and each segment has its own base address. It is basically used to enhance the speed of execution of the computer system, so that the processor is able to fetch and execute the data from the memory easily and fast.</p>
        <b>Need for Segmentation –</b><p>The Bus Interface Unit (BIU) contains four 16 bit special purpose registers (mentioned below) called as Segment Registers.</p>
        <ul>
            <li><b>Code segment register (CS):</b>is used for addressing memory location in the code segment of the memory, where the executable program is stored.</li>
            <li><b>Data segment register (DS):</b>points to the data segment of the memory where the data is stored.</li>
            <li><b>Extra Segment Register (ES):</b>also refers to a segment in the memory which is another data segment in the memory.</li>
            <li><b>Stack Segment Register (SS):</b>s used for addressing stack segment of the memory. The stack segment is that segment of memory which is used to store stack data.</li>
        </ul>
        <p>The number of address lines in 8086 is 20, 8086 BIU will send 20bit address, so as to access one of the 1MB memory locations. The four segment registers actually contain the upper 16 bits of the starting addresses of the four memory segments of 64 KB each with which the 8086 is working at that instant of time. A segment is a logical unit of memory that may be up to 64 kilobytes long. Each segment is made up of contiguous memory locations. It is an independent, separately addressable unit. Starting address will always be changing. It will not be fixed.</p>
        <p class="note">Note that the 8086 does not work the whole 1MB memory at any given time. However, it works only with four 64KB segments within the whole 1MB memory.</p>
        <p>Below is the one way of positioning four 64 kilobyte segments within the 1M byte memory space of an 8086.</p>
        <img src="{% static 'mp_img/ch1_mem_segm.png'%}" alt="">
        <p><b>Types Of Segmentation –</b></p>
        <ol>
            <li><b>Overlapping Segment –</b>A segment starts at a particular address and its maximum size can go up to 64kilobytes. But if another segment starts along with this 64kilobytes location of the first segment, then the two are said to be Overlapping Segment.</li>
            <li><b>Non-Overlapped Segment – </b>A segment starts at a particular address and its maximum size can go up to 64kilobytes. But if another segment starts before this 64kilobytes location of the first segment, then the two segments are said to be Non-Overlapped Segment.</li>
        </ol>
        <p>Rules of Segmentation Segmentation process follows some rules as follows:</p>
        <ul>
            <li>The starting address of a segment should be such that it can be evenly divided by 16.</li>
            <li>Minimum size of a segment can be 16 bytes and the maximum can be 64 kB</li>
            <img src="{% static 'mp_img/ch1_mem_segm2.png'%}" alt="">
        </ul>
        <p>Advantages of the Segmentation The main advantages of segmentation are as follows:</p>
        <ul>
            <p>It provides a powerful memory management mechanism.</p>
            <p>Data related or stack related operations can be performed in different segments.</p>
            <p>Code related operation can be done in separate code segments.</p>
            <p>It allows to processes to easily share data.</p>
            <p>It allows to extend the address ability of the processor, i.e. segmentation allows the use of 16 bit registers to give an addressing capability of 1 Megabytes. Without segmentation, it would require 20 bit registers.</p>
            <p>It is possible to enhance the memory size of code data or stack segments beyond 64 KB by allotting more than one segment for each area.</p>
        </ul>
    </article>
    <!-- 8086 MEMORY SEGMETATION END -->
    <br>

    <!-- 8086 MEMORY BANKING START -->
    <article>
        <h3 id="8086_mem_bank">8086 Memory Banking</h3>
        <br>
        <p>THe 8086 processor provides a 16-bit data bus. So it is capable of transferring in 16 bit in one cycle but each memory locatin is only of a byte, therefore we need 2 cycles to access16 bit ( 8 bit each) from two different memory location. The solution to this problem is Memory Banking. Through Memory banking, our goal is to access two consecutive memory locatin in one cycle(tranfer 16 bit)</p>
        <p>The memory chip is equally divided into two parts(banks). One of the banks contains even addresses called Even bank and the other contains odd addresses called Odd bank. Even bank always gives lower byte So Even bank is also called Lower bank(LB) and Odd bank is also called Higher bank(HB).</p>
        <li>This banking scheme allows to access two aligned memory locations from both banks simultaneously and process 16-bit data transfer. Memory banking doesn’t make it compulsory to transfer 16 bits, it facilitates the 16-bit data transfer. </li>
        <li>The choice between 8 bit and 16-bit transfer depends on the instructions given by the programmer. </li>
        <b>Example: </b>
        <img src="{% static 'mp_img/memory_banking1.png' %}" alt="">
        <p>The Least Significant bit of address (A0 is not used for byte selection) is reserved for bank selection. Therefore A0=0 will select Even bank. The BHE signal is used for the selection of odd banks. The processor will use a combination of these two signals to decide the type of data transfer. </p> 
        <img src="{% static 'mp_img/memory_banking2.png' %}" alt="">
    </article>
    <!-- 8086 MEMORY BANKING ENDS -->
    <br>

    <!-- 8086 PIN DIAGRAM START -->
    <article>
        <h3 id="8086_pin_diag">8086 Pin Diagram</h3>
        <p>8086 was the first 16-bit microprocessor available in 40-pin DIP (Dual Inline Package) chip. Let us now discuss in detail the pin configuration of a 8086 Microprocessor.</p>
        <p>Here is the pin diagram of 8086 microprocessor −</p>
        <img src="{% static 'mp_img/ch1_pin_diag.jpg' %}" alt="">
        <p><b>Power supply and frequency signals</b></p><p>It uses 5V DC supply at VCC pin 40, and uses ground at VSS pin 1 and 20 for its operation</p>
        <b>Clock signal</b><p>Clock signal is provided through Pin-19. It provides timing to the processor for operations. Its frequency is different for different versions, i.e. 5MHz, 8MHz and 10MHz</p>
        <b>Address/data bus</b><p>AD0-AD15. These are 16 address/data bus. AD0-AD7 carries low order byte data and AD8AD15 carries higher order byte data. During the first clock cycle, it carries 16-bit address and after that it carries 16-bit data.</p>
        <b>Address/status bus</b><p>A16-A19/S3-S6. These are the 4 address/status buses. During the first clock cycle, it carries 4-bit address and later it carries status signals.</p>
        <b>S7/BHE</b><p>BHE stands for Bus High Enable. It is available at pin 34 and used to indicate the transfer of data using data bus D8-D15. This signal is low during the first clock cycle, thereafter it is active.</p>
        <b>Read($\overline{RD}$)</b><p>It is available at pin 32 and is used to read signal for Read operation.</p>
        <b>Ready</b><p>It is available at pin 22. It is an acknowledgement signal from I/O devices that data is transferred. It is an active high signal. When it is high, it indicates that the device is ready to transfer data. When it is low, it indicates wait state.</p>
        <b>RESET</b><p>It is available at pin 21 and is used to restart the execution. It causes the processor to immediately terminate its present activity. This signal is active high for the first 4 clock cycles to RESET the microprocessor.</p>
        <b>INTR</b><p>It is available at pin 18. It is an interrupt request signal, which is sampled during the last clock cycle of each instruction to determine if the processor considered this as an interrupt or not</p>
        <b>NMI</b><p>It stands for non-maskable interrupt and is available at pin 17. It is an edge triggered input, which causes an interrupt request to the microprocessor.</p>
        <i>$\overline{TEST}$</i>
        <p>This signal is like wait state and is available at pin 23. When this signal is high, then the processor has to wait for IDLE state, else the execution continues.</p>
        <b>MN/$\overline{MX}$</b><p>It stands for Minimum/Maximum and is available at pin 33. It indicates what mode the processor is to operate in; when it is high, it works in the minimum mode and vice-aversa</p>
        <b>INTA</b><p>It is an interrupt acknowledgement signal and id available at pin 24. When the microprocessor receives this signal, it acknowledges the interrupt</p>
        <b>ALE</b><p>It stands for address enable latch and is available at pin 25. A positive pulse is generated each time the processor begins any operation. This signal indicates the availability of a valid address on the address/data lines.</p>
        <b>DEN</b><p>It stands for Data Enable and is available at pin 26. It is used to enable Transreceiver 8286. The transreceiver is a device used to separate data from the address/data bus.</p>
        <b>DT/R</b><p>It stands for Data Transmit/Receive signal and is available at pin 27. It decides the direction of data flow through the transreceiver. When it is high, data is transmitted out and vice-a-versa.</p>
        <b>M/IO</b><p>This signal is used to distinguish between memory and I/O operations. When it is high, it indicates I/O operation and when it is low indicates the memory operation. It is available at pin 28.</p>
        <b>WR</b><p>It stands for write signal and is available at pin 29. It is used to write the data into the memory or the output device depending on the status of M/IO signal.</p>
        <b>HLDA</b><p>It stands for Hold Acknowledgement signal and is available at pin 30. This signal acknowledges the HOLD signal</p>
        <b>HOLD</b><p>This signal indicates to the processor that external devices are requesting to access the address/data buses. It is available at pin 31</p>
        <b>QS1 and QS0</b><p>These are queue status signals and are available at pin 24 and 25. These signals provide the status of instruction queue. Their conditions are shown in the following table −</p>
        <table>
            <tr>
                <th>QS0</th>
                <th>QS1</th>
                <th>STATUS</th>
            </tr>
            <tr>
                <th>o</th>
                <th>0</th>
                <th>No operation</th>
            </tr>
            <tr>
                <th>0</th>
                <th>0</th>
                <th>First byte of opcode from the queue</th>
            </tr>
            <tr>
                <th>1</th>
                <th>0</th>
                <th>Empty the queue</th>
            </tr>
            <tr>
                <th>1</th>
                <th>1</th>
                <th>Subsequent byte from the queue</th>
            </tr>
        </table>
        <b>S0, S1, S2</b><p>These are the status signals that provide the status of operation, which is used by the Bus Controller 8288 to generate memory & I/O control signals. These are available at pin 26, 27, and 28. Following is the table showing their status −</p>
        <table>
            <tr>
                <th>S2</th>
                <th>S1</th>
                <th>S0</th>
                <th>STATUS</th>
            </tr>
            <tr>
                <th>0</th>
                <th>0</th>
                <th>0</th>
                <th>Interrupt Acknowledgement</th>
            </tr>
            <tr>
                <th>0</th>
                <th>0</th>
                <th>1</th>
                <th>I/O Read</th>
            </tr>
            <tr>
                <th>0</th>
                <th>1</th>
                <th>0</th>
                <th>I/O Write</th>
            </tr>
            <tr>
                <th>0</th>
                <th>1</th>
                <th>1</th>
                <th>Halt</th>
            </tr>
            <tr>
                <th>1</th>
                <th>0</th>
                <th>0</th>
                <th>Opcode fetch</th>
            </tr>
            <tr>
                <th>1</th>
                <th>0</th>
                <th>1</th>
                <th>Memory read</th>
            </tr>
            <tr>
                <th>1</th>
                <th>1</th>
                <th>0</th>
                <th>memory write</th>
            </tr>
            <tr>
                <th>1</th>
                <th>1</th>
                <th>1</th>
                <th>Passive</th>
            </tr>
        </table>
        <b>LOCK</b><P>When this signal is active, it indicates to the other processors not to ask the CPU to leave the system bus. It is activated using the LOCK prefix on any instruction and is available at pin 29.</P>
        <b>RQ/GT1 and RQ/GT0</b><p>These are the Request/Grant signals used by the other processors requesting the CPU to release the system bus. When the signal is received by CPU, then it sends acknowledgment. RQ/GT0 has a higher priority than RQ/GT1.</p>
        <br>
    </article>
    <!-- 8086 PIN DIAGRAM END -->
    <br>

</section>
<!-- CHAPTER 1 ENDS HERE -->

<!-- CHAPTER 2 START -->
<section class="main-section">
    <header id="chap2">Chapter 2:8086 Assembly Language </header>
    <br>

    <!-- Addressing Modes START -->
    <article>
        <h3 id="8086_Addg_Modes">8086 Addressing Modes</h3>
        <p>The different ways in which a source operand is denoted in an instruction is known as addressing modes. There are 8 different addressing modes in 8086 programming −</p>
        <b>Immediate addressing mode</b><p>The addressing mode in which the data operand is a part of the instruction itself is known as immediate addressing mode.</p>
        <p>Example</p>
        <p class="note">MOV CX, 4929 H, ADD AX, 2387 H,  MOV AL, FFH </p>
        <b>Register addressing mode</b><p>It means that the register is the source of an operand for an instruction.</p>
        <p>Example</p>
        <div class="note">
            MOV CX, AX ; copies the contents of the 16-bit AX register into
            <p> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;         ; the 16-bit CX register),</p>
            ADD BX, AX
        </div>
        <b>Direct addressing mode</b>
        <p>The addressing mode in which the effective address of the memory location is written directly in the instruction.</p>
        <p>Example</p>
        <p class="note">MOV AX, [1592H], MOV AL, [0300H]</p>
        <b>Register indirect addressing mode</b>
        <p>This addressing mode allows data to be addressed at any memory location through an offset address held in any of the following registers: BP, BX, DI & SI.</p>
        <p>Example</p>
        <div class="note">
                <p>MOV AX, [BX]  ; Suppose the register BX contains 4895H, then the contents</p>
                <p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 4895H are moved to AX </p>
                <p>ADD CX, {BX</p>
        </div>
        <b>Based addressing mode</b>
        <p>In this addressing mode, the offset address of the operand is given by the sum of contents of the BX/BP registers and 8-bit/16-bit displacement.</p>
        <p>Example</p>
        <p class="note">MOV DX, [BX+04], ADD CL, [BX+08]</p>
        <b>Indexed addressing mode</b>
        <p>In this addressing mode, the operands offset address is found by adding the contents of SI or DI register and 8-bit/16-bit displacements.</p>
        <p>Example</p>
        <p class="note">MOV BX, [SI+16], ADD AL, [DI+16] </p>
        <b>Based-index addressing mode</b>
        <p>In this addressing mode, the offset address of the operand is computed by summing the base register to the contents of an Index register.</p>
        <p>Example</p>
        <p class="note">ADD CX, [AX+SI], MOV AX, [AX+DI] </p>
        <b>Based indexed with displacement mode</b>
        <p>In this addressing mode, the operands offset is computed by adding the base register contents. An Index registers contents and 8 or 16-bit displacement.</p>
        <p>Example</p>
        <p class="note">MOV AX, [BX+DI+08], ADD CX, [BX+SI+16]</p>
    </article>
    <!-- Addressing Modes END -->
    <br>

    <!-- DATA MEMORY ADDRESSING MODES START -->
    <article>
        <h3 id="Data_mem_addrg_mode">Data Memory Addressing Mode</h3>
        <p>In this type of addressing mode, first the offset address is calculated, then the memory address is calculated and then the operand form that memory location is fetched. There are following modes which lie under the Data Addressing Mode:</p>
        <ol>
            <li>
                <h5><b>Direct Addressing Mode</b></h5>
                <p>In this addressing mode, the offset is specified within the instructions. What this means is that the offset address is directly stored within square brackets and is not present inside any register.</p>
                <b>Example:</b>
                <p class="note">MOV AL, [4000H] <br>  MOV [1234H], BX </p>
            </li>
            <li>
                <h5><b>Base Addressing Mode</b></h5>
                <p>In this addressing mode, the offset address for any operand is stored in the base register BX.</p>
                <b>Example:</b>
                <p class="note">MOV AL, [BX]</p>
            </li>
            <li>
                <h5><b>Base Relative Addressing Mode</b></h5>
                <p>In this addressing mode also, the offset address is stored within the Base register but the difference is that there is some displacement present with it. This displacement can be either of 8 bits or 16 bits. Hence, the offset address will be equal to the contents of the base register + 8/16 bit displacement.</p>
                <b>Example:</b>
                <p class="note">MOV AL, [BX + 05H]	{here, displacement is of 8 bits} <br> MOV AL, [BX+1243H] 	{here, displacement is of 16 bits}</p>
            </li>
            <li>
                <h5><b>Index Addressing Mode</b></h5>
                <p>In this addressing mode, the offset address is defined in the Index Register. (It should be noted here that the Index registers act as an offset for Data Segment as well.) So, the memory location of the operand is calculated with the help of DS and SI.</p>
                <b>Example:</b>
                <p class="note">MOV BL, [SI] <br> MOV [SI], DH</p>
            </li>
            <li>
                <h5><b>Index relative addressing mode</b></h5>
                <p>In this addressing mode, the offset address is equal to the content of index register plus the 8 or 16-bit displacement. It is important to note here that the displacement in all relative addressing modes is a signed number, i.e. the displacement value can either be a positive or a negative hexadecimal number.</p>
                <b>Example:</b>
                <p class="note ">MOV BL, [SI + 07H] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {Here, the displacement is of 8 bits} <br>  MOV BL, [SI – 3034H] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 	{Here, the displacement is of 16 bits}</p>
            </li>
            <li>
                <h5><b>Base plus Index Addressing Mode</b></h5>
                <p>In this addressing Mode, the offset address is calculated by both the base register and the index register. Hence, the offset address will be equal to the content of the base register plus the content of the Index register.</p>
                <b>Example:</b>
                <p class="note">MOV AL, [BX + SI] <br>    MOV [BX + SI], CL</p>
            </li>
            <li>
                <h5><b>Base relative plus Index Addressing Mode</b></h5>
                <p>This addressing mode is almost same to the Base plus Index Addressing mode, but like the other relative addressing modes, the difference is only that this mode has a displacement of 8 or 16 bits.</p>
                <b>Example:</b>
                <p class="note">MOV CL, [BX + SI + 0AH] &nbsp;&nbsp;&nbsp;&nbsp;    {here, the displacement is of 8 bits}  <br>    MOV AL, [BX + SI + AE07H] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {here, the displacement is of 16 bits}</p>
            </li>
        </ol>
    </article>
    <!-- DATA MEMORY ADDRESSING MODES END -->
    <br>

    <!-- I/O ADDRESSING MODES OF 8086 START -->
    <article>
        <h5 id="i/o_addrg_modes">I/O Addressing Modes of 8086</h5>
        <ol>
            <li>The 8086 can generate 16-bit of I/O address. Thus it can address up to 64 Kbyte I/O locations or 32 K word I/O locations. </li>
            <li>The 16-bit I/O address appears on A_0 to A_15 address lines; A_16 to A_19 lines are at logic 0 during the I/O operations. </li>
            <li>The 16-bit DX register is used as 16-bit I/O address pointer to address up to 64 IC devices in in-direct addressing mode. </li>
            <li>The 1/0 instructions with direct addressing mode can directly address one or two of the 256 I/O byte locations in page 0 of the 1/0 address space.</li>
            <img src="{% static 'mp_img/ch2_io_addrg_mode.png' %}" class="img-fluid" alt="Error 404">
            <p>I/0 ports are addressed in the same manner as memory locations. Even addressed bytes are transferred on the D_7-D_0 bus lines and odd addressed bytes onD_15-D_8.</p>
            <p>Care must be taken to assure that each register within an 8-bit peripheral located on the lower portion of the bus be addressed as even. </p>
            <p>In the I/O space, Intel has reserved 00F8H to 00FF locations.</p>
        </ol>
    </article>
    <!-- I/O ADDRESSING MODES OF 8086 END -->
    <br>

    <!-- ADDRESSING MODES FOR PROGRAM MEMORY START -->
    <article>
        <h3 id="addrg_mode_pgm_mem">Addressing Modes for Program Memory</h3>
        <p>The Program Memory Addressing mode is used in branch instructions. These branch instructions are instructions which are responsible for changing the regular flow of the instruction execution and shifting the control to some other location. In 8086 microprocessor, these instructions are usually JMP and CALL instructions</p>
        <p>The Program memory Addressing Mode contains further three addressing modes within it. They are:</p>
        <ol>
            <li>
                <h5><b>Direct Program Memory Addressing</b></h5>
                <p>In this addressing mode, the offset address where the control is to be shifted is defined within the instruction. This mode is called direct addressing mode because the required address is directly present in the instruction rather than being stored in some register.</p>
                <p>Example:</p>
                <p class="note">JMP 4032H</p>
                <p>Here, the working of the above instruction will be as follows:</p>
                <p>The current value of IP which holds the address of next instruction to be executed will be stored in the TOP OF THE STACK. Now, the IP will be replaced by the mentioned value, i.e. IP <- 4032H</p>
                <p>Now, the Memory address is calculated as: (Contents of CS) X 10H + (contents of IP)</p>
            </li>
            <li>
                <h5><b>Indirect Program Addressing mode</b></h5>
                <p>As the name suggests, in this addressing mode, the offset address is not present directly in the instruction. It is rather stored in any of the CPU registers (Internal Register). So, the contents of the Instruction Pointer (IP) will be replaced by the contents of that register.</p>
                <b>Example:</b>
                <p class="note">JMP BX</p>
                <b>Working:</b>
                <p>Suppose that the content of the BX register is 0003H. So, the working of the microprocessor for executing the above instruction will be as follows:</p>
                <div class="note">
                    <p> IP <- contents of BX</p>
                    <p>i.e.&nbsp; IP <- 0003H</p>
                </div>
                <p>And the required memory address is calculated in a similar way as in Direct Addressing mode: (Contents of CS) X 10H + (contents of IP)</p>
            </li>
            <li>
                <h5><b>Relative Program Memory Addressing</b></h5>
                <p>In this Addressing mode, the offset address is equal to the content of the Instruction Pointer (IP) plus the 8 or 16-bit displacement. For the 8 bit displacement, SHORT is used and for 16-bit displacement, LONG is used. This type of displacement will only be intra-segment, i.e. within the segment.</p>
                <b>Example:</b>
                <p class="note">JMP SHORT OVER</p>
                <p>Here, SHORT is used to represent the 8-bit displacement and OVER is the Label defined for any particular memory location.</p>
            </li>
        </ol>

    </article>
    <!-- ADDRESSING MODES FOR PROGRAM MEMORY END -->
    <br>

    <!-- 8086 SOFTWARE MODEL START -->
    <article>
        <h3 id="soft_mdl">8086 Software Model</h3>
        <img src="{% static 'mp_img/ch2_soft_mdl_8086.jpg' %}" alt="">
        <p>Software Mode, also called Programmers model, Means all the refisters available to the progreammer. ID Programmers Model is asked in the exam, draw the above diagram and explain all the registers from the architecture answer</p>
        <p>It must include <b>All GPRs: AC, BX, CX,DX. Segment Register: CS, SS,DS,ES, akk Offset Regisers: IP, SO, BP,SI, DI and Flag Register</b></p>
        <p>The explanation of these register has alreafy been included in architecture</p>

    </article>
    <!-- 8086 SOFTWARE MODEL END -->

    <br>

    <!-- 8086 INSTRUCTION SET START -->
    <article>
        <h3 id="8086_intutn_set ">8086 Instruction Set</h3>
        <b>Classification of Instruction Set of 8086</b>
        <ol>
            <li>
                <b>Data Tranfer Instruction</b>
                <p>Eg: MOV, PUSH, POP</p>
            </li>
            <li>
                <b>Arithmetic Instruction</b>
                <p>Eg: ADD, SUB, MUL</p>
            </li>
            <li>
                <b>Logic Instruction(Bit Manipulatin Instruction)</b>
                <p>Eg:AND, OR, XOR</p>
            </li>
            <li>
                <b>Shift Instruction And Rotate Instruction</b>
                <p>Eg: ROL, RCL, ROR, SHL</p>
            </li>
            <li>
                <b>Program Execution and Transfer Instruction(Branch Instruction)</b>
                <p>Eg: JMP, CALL, JC</p>
            </li>
            <li>
                <b>Iteration Control Instruction(Loop Instruction)</b>
                <p>Eg: LOOP, LOOPZ,LOOPNE</p>
            </li>
            <li>
                <b>Processor Control Instructions(Instructin Operating on Flag)</b>
                <p>Eg: STC , CLC, CMC</p>
            </li>
            <li>
                <b>External Hardware Synchronization Instructions</b>
                <p>Eg: LOCK, ECS, WAIT</p>
            </li>
            <li>
                <b>Interrupt Control Instruction</b>
                <p>Eg: INT n, IRET, INTO (Interrupt on overflow)</p>
            </li>
            <li>
                <b>String Instruction</b>
                <p>Eg: MOVSB, LODSB, STOSB</p>
            </li>
        </ol>
    </article>
    <!-- 8086 INSTRUCTION SET END -->

    <br>

    <!-- DATA TRANFER INSTRUCTION START -->
    <article>
        <h3 id="dtinst">Data Tranfer Instruction</h3>
        <p>The data transfer instructions are used to transfer data from one location to another. This transfer of data can be either from register to register, register to memory or memory to register.</p>
        <p>It is important to note here that the memory to memory transfer of data directly is not possible.</p>
        <p>Following are some instructions that are used for data transfer purpose:</p>
        <ol>
            <li>MOV</li>
            <li>PUSH</li>
            <li>POP</li>
            <li>XCHG</li>
            <li>LAHF</li>
            <li>SAHF</li>
            <li>IN</li>
            <li>OUT</li>
            <li>LDS</li>
            <li>LES</li>
        </ol>
        <ol>
            <li>
                <b>MOV</b>
                <p>This instruction simply copies the data from the source to the destination.</p>
                <div class="note">
                    <p>   Syntax: 	MOV destination , source</p>
                    <p>    Example: 	MOV AX, BX</p>
                </div>
            </li>
            <li>
                <b>PUSH</b>
                <p>This instruction is used to push data into the stack.</p>
                <div class="note"> 
                    <p> Syntax:     PUSH source</p>
                    <p>Example:    PUSH CX</p>
                    <!-- <p>Working:    SP  <-  SP - 1</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[SP] <- CH</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SP <-  SP - 1</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[SP]  <-  CL</p> -->
                </div>
            </li>
            <li>
                <b>POP</b>
                <p>This instruction is used to get the data from the stack.</p>
                <div class="note">
                    <p>Syntax:     POP destination</p>
                    <p>Example:    POP CX</p>
                    <!-- <p>Working:    CL<-  [SP]</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SP <- SP + 1</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CL  <-  [SP]</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SP <-  SP+ 1</p> -->
                </div>
            </li>
            <li>
                
                <b>XCHG</b>
                <p>It exchanges the contents of the source and the destination.</p>
                <div class="note">
                    <p>Syntax:     XCHG destination, source</p>
                    <p>Example:    XCHG BL, AL</p>
                </div>
            </li>
            <li>
                <b>LAFH</b>
                <p>It stands for 'Load AHfrom Flag register'. This instruction will, therefore, load the AH register with the content of lower byte of the flag register</p>
                <div>
                    <!-- <p>Syntax:     LAHF</p>
                    <p>Working:    AH <- lower byte of the flag register</p> -->
                </div>
            </li>
            <li>
                <b>SAHF</b>
                <p>t stands for 'Store AH to Flag register'. This instruction stores the content of AH register to the lower byte of flag register.</p>
                <div class="note">
                    <!-- <p>Syntax:     SAHF</p>
                    <p>Working:    Lower Byte of flag register <- AH</p> -->
                </div>
            </li>
            <li>
                <b>IN</b>
                <p>This instruction is used to transfer data from the input unit to accumulator.</p>
                <div>
                    <p>Syntax:     IN accumulator, Port address</p>
                    <p>Working:    The content from the input unit whose address in mentioned in the instruction is transferred to the accumulator </p>
                    
                    <p>Example:    IN AX, 1326H</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IN AL, DX</p>
                </div>
            </li>
            <li>
                <b>OUT</b>
                <p>This instruction is used to transfer data from accumulator to the output unit.</p>
                <div class="note">
                    <p>Syntax:     OUT Port address, accumulator</p>
                    <p>Working:    The content from the accumulator which is the AX registeris</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; transferred to the output unit whose address in mentioned in </p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the instruction.</p>
                    <p>Example:    OUT 1326H, AL</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OUT DX, AX</p>
                </div>
            </li>
            <li>
                <b>LDS</b>
                <p>This instruction will load the register that is defined in the instruction and the data segment (DS) from the source.</p>
                <div class="note">
                    <p>Syntax:     LDS destination, source</p>
                    <p>Example:    LDS BX , [SI]</p>
                    <!-- <p>Working:    BL <-  [SI]</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BH  <-  [SI + 1]</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DS  <-  [ SI + 3  :  SI + 2]</p> -->
                </div>
            </li>
            <li>
                <b> LES</b>
                <p>The working and syntax of this instruction is the same as the LDS. The difference is only that instead of data segment register (DS), Extra Segment register (ES) is used.</p>
            </li>
        </ol>

    </article>
    <!-- DATA TRANFER INSTRUCTION END -->

    <br>

    <!-- ARITHMETIC INSTRUCTION START -->
    <article>
        <h3 id="arith_inst"> Arithmetic Instruction</h3>
        <p>These instructions are used to perform arithmetic operations like addition, subtraction, multiplication, division, etc. In 8086 the destination address is need not to be the accumulator.</p>
        <p>Let us see the arithmetic instructions of 8086 microprocessor. Here the D and S are destination and source respectively. D and S can be either register, data or memory address.</p>
        <table>
            <tr>
                <th>Opcode</th>
                <th>Operand</th>
                <th>Description</th>
            </tr>
            <tr>
                <th><b>ADD</b></th>
                <th>D,S</th>
                <th>Used to add the provided byte to byte/word to word</th>
            </tr>
            <tr>
                <th><b>ADS</b></th>
                <th>D,S</th>
                <th>Used to Add with Carry</th>
            </tr>
            <tr>
                <th><b>TNC</b></th>
                <th>D</th>
                <th>Used to increment thr provided byte/word by 1</th>
            </tr>
            <tr>
                <th><b>AAA</b></th>
                <th>---</th>
                <th>Used to adjust ASCII after addition</th>
            </tr>
            <tr>
                <th><b>DSS</b></th>
                <th>---</th>
                <th>USed to adjust the decimal after te addition/subtraction operation</th>
            </tr>
            <tr>
                <th><b>SUB</b></th>
                <th>D,S</th>
                <th>Used to subtract the byte from byte/ word from word</th>
            </tr>
            <tr>
                <th><b>SBB</b></th>
                <th>D,S</th>
                <th>Used to prefrom subtraction with borrow</th>
            </tr>
            <tr>
                <th><b>DEC</b></th>
                <th>D</th>
                <th>Used to decrement the provided byte/word by 1</th>
            </tr>
            <tr>
                <th><b>NEG</b></th>
                <th>D</th>
                <th>Used to negate each bit of the provided byte/word and add 1/2 complement</th>
            </tr>
            <tr>
                <th><b>CMP</b></th>
                <th>D</th>
                <th>Used to compare 2 provided byte/word</th>
            </tr>
            <tr>
                <th><b>AAS</b></th>
                <th>---</th>
                <th>Used to adjust ASCII codes after subtraction</th>
            </tr>
            <tr>
                <th><b>DAS</b></th>
                <th>---</th>
                <th>Used to adjust decimal after subtraction.</th>
            </tr>
            <tr>
                <th><b>MUL</b></th>
                <th>8-bit reg</th>
                <th>Used to multiply unsigned byte by byte/word by word.</th>
            </tr>
            <tr>
                <th><b>IMUL</b></th>
                <th>8  or 16 bit reg</th>
                <th>Used to multiply signed byte by byte/word by word.</th>
            </tr>
            <tr>
                <th><b>AAM</b></th>
                <th>---</th>
                <th>Used to adjust ASCII codes after multiplication.</th>
            </tr>
            <tr>
                <th><b>DIV</b></th>
                <th>8-bit reg</th>
                <th>Used to divide the unsigned word by byte or unsigned double word by word.</th>
            </tr>
            <tr>
                <th><b>IDIV</b></th>
                <th>8 or 16-bit reg </th>
                <th>Used to divide the signed word by byte or signed double word by word.</th>
            </tr>
            <tr>
                <th><b>AAD</b></th>
                <th>---</th>
                <th>Used to adjust ASCII codes after division.</th>
            </tr>
            <tr>
                <th><b>CBW</b></th>
                <th>---</th>
                <th>Used to fill the upper byte of the word with the copies of sign bit of the lower byte.</th>
            </tr>
            <tr>
                <th><b>CWD</b></th>
                <th>---</th>
                <th>Used to fill the upper word of the double word with the sign bit of the lower word</th>
            </tr>
        </table>    
    </article>
    <!-- ARITHMETIC INSTRUCTION ENDS -->
    <br>

    <!-- DECIMAL ADJUST INSTRUCTION START -->
    <article>
        <h3 id="dec_adj_inst">Decimal Adjust Instructions</h3>
        <ol>
            <li>
                <h5><b>DAA</b></h5>
                <ul>
                    <li>The DAA (Decimal Adjust after Addition) instruction allows addition of numbers represented in 8-bit packed BCD code. It is used immediately after normal addition instruction operating on BCD codes. This instruction assumes the AL register as the source and the destination, and hence it requires no operand.</li>
                    <li>The effect of DAS (Decimal Adjust after Subtraction) instruction is similar to that of DAA, except that it is used after a subtraction instruction</li>
                    <li>For example in the following program, that NUM1 and NUM2 are decimal numbers coded in BCD format, the result should be 61</li>
                    <code>
                        .MODEL SMALL
                        .STACK 200
                        .DATA
                        NUM1	DB 	27H
                        NUM2	DB	35H	
                        .CODE
                        .STARTUP

                    	    MOV	AL,  NUM1	;load AX with number NUM1
                        	ADD 	AL,  NUM2	;AL = AL + NUM2 i.e. AL = 5CH = 92 in decimal
                        	;The expected result is 62 in decimal
                        	DAA			; AL = 62
                        .EXIT
                        END
                    </code>
                    <b>DAA operation:</b>
                    <p>For the processor there is no difference between a BCD and a hexadecimal number, all numbers are seen as hexadecimal numbers. After performing an addition and the result is saved in the AL register, conversion to decimal is carried out as follows:</p>
                    <ul>
                        <li>if the digit in the lower four nibbles of AL is greater than 10 (decimal),</li>
                        <li>then subtract 10 and</l>
                        <li>add 1 to the digit in the higher four nibbles of AL</li>
                    </ul>

                </ul>
            </li>
            <li>
                <h5><b>DAS</b></h5>
                <p>Decimal Adjust after Subtraction:- This instruction converts the result of subtraction operation of 2 packed BCD numbers to a valid BCD number. The subtraction operation has to be only in the AL. If the lower nibble of AL is higher than the value 9, this instruction will subtract 06 from lower nibble of the AL. If the output of subtraction operation sets the carry flag or if the upper nibble is higher than value 9, it subtracts 60H from the AL. This instruction modifies the CF, AF, PF, SF and ZF flags. The OF is not defined after DAS instruction. The instance is following:</p>
                <img src="{% static 'mp_img/chp2_das.jpg' %}" class="img-fluid ${3|rounded-top,rounded-right,rounded-bottom,rounded-left,rounded-circle,|}" alt="">
            </li>
        </ol>
    </article>
    <!-- DECIMAL ADJUST INSTRUCTION END -->
    <br>

    <!-- ASCII ADJUST INSTRUCTION START -->
    <article>
        <h3 id="ascii_adj_inst">ASCII Adjust Instructions</h3>
        <ol>
            <li>
                <h5><b>AAA Instruction</b></h5>
                <ul>
                    <li>Adjust the sum of two unpacked BCD values to create an unpacked BCD result.</li>
                    <li>The AL register is the implied source and destination operand for this instruction.</li>
                    <li>The AAA instruction is only useful when its follow an ADD instruction that adds (binary addition) two unpacked BCD values.</li>
                    <li>The AAA instruction then adjusts the contents of AL register to contain the correct 1-digit unpacked BCD result.</li>
                    <li>If the addition produces a decimal carry, the AH register is incremented by 1, and the CF and AF flags are set</li>
                </ul>
            </li>
            <li>
                <h5><b>AAD Instruction</b></h5>
                <ul>
                    <li>Unlike all other adjustment instructions, the AAD instruction appears before a division.</li>
                    <li>The AAD instruction requires that the AX register contain a two-digit unpacked BCD number (not ASCII) before executing</li>
                    <li>After adjusting the AX register with AAD, it is divided by an unpacked BCD number to generate a single-digit result in AL with any remainder in AH.</li>
                    <li>Example:</li>
                    <code>
                        MOV BL, 9H
                        MOV AX, 702H
                        AAD
                        DIV BL
                    </code>
                    <LI>The above example show how 72 is unpacked BCD is divided by 9 to produce a quotient of 8. The 0702H loaded into AX register is adjusted by the AAD instruction to 0048H.</LI>
                </ul>
            </li>
            <li>
                <h5><b>AAM Instruction</b></h5>
                <ul>
                    <li>Adjust the result of the multiplication of two unpacked BCD values to create a pair of unpacked BCD values.</li>
                    <li>The AX register is the implied source and destination operand for this instruction.</li>
                    <li>The AAM instruction is only useful when it follows an MUL instruction that multiplies (binary multiplication) two unpacked BCD values and stores a word result in AX registers.</li>
                </ul>
            </li>
            <li>
                <h5><b>AAS Instruction</b></h5>
                <ul>
                    <li>Adjust the result of the subtraction of two unpacked BCD values to create a unpacked BCD result.</li>
                    <li>The AL register is the implied source and destination for this instructions.</li>
                    <li>The AAS instruction is only useful when it follows a SUB instruction that subtracts (binary subtraction) one unpacked BCD valued from another and stores a byte result in the AL register.</li>
                    <li>If the subtraction produced a decimal carry, the AH register is decremented by 1, and the CF and AF flags are set.</li>
                    <li>If no decimal carry occurred, the CF and AF flags are cleared, and the AH register is unchanged.</li>
                </ul>
            </li>
        </ol>
        
    </article>
    <!-- ASCII ADJUST INSTRUCTION END -->

    <!-- LOGIC INSTRUCTION START -->
    <article>
        <h3 id="log_inst">Logic Instructions</h3>
        <ul>
            <li>These instructions are used to perform operations where data bits are involved, i.e. operations like logical, shift, etc. We can say that these instructions are logical instructions. In 8086, the destination register may or may not the Accumulator.</li>
            <li>Let us see the logical instructions of 8086 microprocessor. Here the D, S and C are destination and source and count respectively. D, S and C can be either register, data or memory address.</li>
            <table>
                <tr>
                    <th>Opcode</th>
                    <th>Operand</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <th><b>ADD</b></th>
                    <th>D,S</th>
                    <th>Used to add the provided byte to byte/word to word</th>
                </tr>
                <tr>
                    <th>OR</th>
                    <th>D,S</th>
                    <th>Used to multiply each bit in a byte/word with the corresponding bit in another byte/word.</th>
                </tr>
                <tr>
                    <th>NOT</th>
                    <th>D</th>
                    <th>Used to invert each bit of a byte or word.</th>
                </tr>
                <tr>
                    <th>XOR</th>
                    <th>D,S</th>
                    <th>Used to perform Exclusive-OR operation over each bit in a byte/word with the corresponding bit in another byte/word</th>
                </tr>
                <tr>
                    <th>TEST</th>
                    <tr>D,S</tr>
                    <th>Used to add operands to update flags, without affecting operands</th>
                </tr>
                <tr>
                    <th>SHR</th>
                    <th>D,C</th>
                    <th>Used to shift bits of a byte/word towards the right and put zero(S) in MSBs.</th>
                </tr>
                <tr>
                    <th>SHR</th>
                    <th>D,C</th>
                    <th>Used to shift bits of a byte/word towards the right and put zero(S) in MSBs.</th>
                </tr>
                <tr>
                    <th>SHL/SAL</th>
                    <th>D,C</th>
                    <th>Used to shift bits of a byte/word towards left and put zero(S) in LSBs</th>
                </tr>
                <tr>
                    <th>ROR</th>
                    <th> D,C</th>
                    <th>Used to rotate bits of byte/word towards the right, i.e. LSB to MSB and to Carry Flag [CF].</th>
                </tr>
                <tr>
                    <th>ROL</th>
                    <th>D,C</th>
                    <th>Used to rotate bits of byte/word towards the left, i.e. MSB to LSB and to Carry Flag [CF].</th>
                </tr>
                <tr>
                    <th>RCR</th>
                    <th>D,C</th>
                    <th>Used to rotate bits of byte/word towards the right, i.e. LSB to CF and CF to MSB.</th>
                </tr>
                <tr>
                    <th>RCL</th>
                    <th>D,C</th>
                    <th>Used to rotate bits of byte/word towards the left, i.e. MSB to CF and CF to LSB.</th>
                </tr>
            </table>
        </ul>
    </article>
    <!-- LOGIC INSTRUCTION ENDS -->
    <br> 

    <!-- SHIFT INSTRUCTIONS START -->
    <article>
        <h3 id="shi_inst">Shift Instruction </h3>
        <p>As we know that any machine (system) works on machine language, which consists of binary numbers. In the 8086 microprocessor, we have 16-bit registers to handle our data. Sometimes, the need to perform some necessary shift and rotate operations on our data may occur according to the given condition and requirement. So, for that purpose, we have various Shift and Rotate instructions present in the 8086 microprocessor. Let us discuss them one by one and understand their working:</p>
        <ol>
            <li>SHR : Shift Right</li>
            <li>SAR : Shift Arithmetic Right</li>
            <li>SHL : Shift Left</li>
            <li>SAL : Shift Arithmetic Left</li>
        </ol>
        <ol>
            <li>
                <h5><b>SHR : Shift Right</b></h5>
                <p>The SHR instruction is an abbreviation for ‘Shift Right’. This instruction simply shifts the mentioned bits in the register to the right side one by one by inserting the same number (bits that are being shifted) of zeroes from the left end. The rightmost bit that is being shifted is stored in the Carry Flag (CF).</p>
                <div class="note">
                    <p>Syntax: 	SHR Register, Bits to be shifted</p>
                    <p>Example:	SHR AX, 2</p>
                </div>
                <p>Working:</p>
                <img src="{% static 'mp_img/ch2_shr.webp' %}" alt="">
            </li>
            <li>
                <h5><b>SAR : Shift Arithmetic Right</b></h5>
                <p>The SAR instruction stands for ‘Shift Arithmetic Right’. This instruction shifts the mentioned bits in the register to the right side one by one, but instead of inserting the zeroes from the left end, the MSB is restored. The rightmost bit that is being shifted is stored in the Carry Flag (CF).</p>
                <div class="note">
                    <p>Syntax: 	SAR Register, Bits to be shifted</p>
                    <p>Example:	SAR BX, 5</p>
                </div>
                <p>Working:</p>
                <img src="{% static 'mp_img/ch2_sar.jpg' %}" alt="">
            </li>
            <li>
                <h5><b>SHL : Shift Left</b></h5>
                <p>The SHL instruction is an abbreviation for ‘Shift Left’. This instruction simply shifts the mentioned bits in the register to the left side one by one by inserting the same number (bits that are being shifted) of zeroes from the right end. The leftmost bit that is being shifted is stored in the Carry Flag (CF).</p>
                <div class="note">
                    <p>Syntax: 	SHL Register, Bits to be shifted</p>
                    <p>Example:	SHL AX, 2</p>
                </div>
                <p>Working:</p>
                <img src="{% static 'mp_img/ch2_shl.jpg' %}" alt="">
            </li>
            <li>
                <h5><b>SAL : Shift Arithmetic Left</b></h5>
                <p>The SAL instruction is an abbreviation for ‘Shift Arithmetic Left’. This instruction is the same as SHL.</p>
                <div class="note">
                    <p>Syntax: 	SAL Register, Bits to be shifted</p>
                    <p>Example:	SAL CL, 2</p>
                </div>
                <p>Working:</p>
                <img src="{% static 'mp_img/ch2_shl.jpg' %}" alt="">
            </li>
        </ol>
    </article>
    <!-- SHIFT INSTRUCTIONS END -->
    <br>

    <!-- ROTATE INSTRUCTION START -->
    <article>
        <h3 id="rte_inst">Rotate Instructions</h3>
        <ol>
            <li>
                <h5><b>ROL : Rotate Left</b></h5>
                <p>The ROL instruction is an abbreviation for ‘Rotate Left’. This instruction rotates the mentioned bits in the register to the left side one by one such that leftmost bit that is being rotated is again stored as the rightmost bit in the register, and it is also stored in theCarry Flag (CF)</p>
                <div class="note">
                    <p>Syntax: 	ROL Register, Bits to be shifted</p>
                    <p>Example:	ROL AH, 4</p>
                </div>
                <p>Working:</p>
                <img src="{% static 'mp_img/ch2_rol.webp' %}" alt="">
            </li>
            <li>
                <h5><b>ROR : Rotate Right</b></h5>
                <p>The ROR instruction stands for ‘Rotate Right’. This instruction rotates the mentioned bits in the register to the right side one by one such that rightmost bit that is being rotated is again stored as the MSB in the register, and it is also stored in the Carry Flag (CF).</p>
                <div class="note">
                    <p>Syntax: 	ROR Register, Bits to be shifted</p>
                    <p>Example:	ROR AH, 4</p>
                </div>
                <p>Working:</p>
                <img src="{% static 'mp_img/chp2_ror.webp' %}" alt="">
            </li>
            <li>
                <h5><b>RCL : Rotate Carry Left</b></h5>
                <p>This instruction rotates the mentioned bits in the register to the left side one by one such that leftmost bit that is being rotated it is stored in the Carry Flag (CF), and the bit in the CF moved as the LSB in the register.</p>
                <div class="note">
                    <p>Syntax: 	RCL Register, Bits to be shifted</p>
                    <p>Example:	RCL CH, 1</p>
                </div>
                <p>Working:</p>
                <img src="{% static 'mp_img/chp2_rcr.webp' %}" alt="">
            </li>
            <li>
                <h5><b>RCR : Rotate Carry Right</b></h5>
                <p>This instruction rotates the mentioned bits in the register to the right side such that rightmost bit that is being rotated it is stored in the Carry Flag (CF), and the bit in the CF moved as the MSB in the register.</p>
                <div class="note">
                    <p>Syntax: 	RCR Register, Bits to be shifted</p>
                    <p>Example:	RCR BH, 6</p>
                </div>
                <p>Working:</p>
                <img src="{% static 'mp_img/chp2_rcl.webp' %}" alt="">
            </li>
        </ol>

    </article>
    <!-- ROTATE INSTRUCTION END -->
    <br>
    
    <!-- BRANCH INSTRUCTION START -->
    <article>
        <h3 id="brh_inst">Branch Instruction</h3>
        <p>These instructions are used to transfer/branch the instructions during an execution. There are two types of branching instructions. The unconditional branch and conditional branch.</p>
        <p>The Unconditional Program execution transfer instructions are as follows.</p>
        <table >
            <thead>
                <tr>
                    <th><strong>Opcode</strong><br></th>
                    <th><strong>Operand</strong><br></th>
                    <th style="text-align: center;"><strong>Description</strong><br></th>
                </tr>
            </thead><tbody>
                <tr>
                    <td><strong>CALL</strong><br></td>
                    <td>address<br></td>
                    <td>Used to call a procedure and save their return address to the stack.<br></td>
                </tr>
                <tr>
                    <td><strong>RET</strong><br></td>
                    <td>----<br></td>
                    <td>Used to return from the procedure to the main program.<br></td>
                </tr>
                <tr>
                    <td><strong>JMP</strong><br></td>
                    <td>address<br></td>
                    <td>Used to jump to the provided address to proceed to the next instruction.<br></td>
                </tr>
                <tr>
                    <td><strong>LOOP</strong><br></td>
                    <td>address<br></td>
                    <td>Used to loop a group of instructions until the condition satisfies, i.e., CX = 0<br></td>
                </tr>
            </tbody>
        </table>

        <p>Now let us see the Conditional Program execution transfer instructions.</p>
        <table class="table table-bordered">
            <thead>
                <tr>
                    <th><strong>Opcode</strong><br></th>
                    <th><strong>Operand</strong><br></th>
                    <th style="text-align: center;"><strong>Description</strong><br></th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>JC</strong><br></td>
                    <td>address<br></td>
                    <td>Used to jump if carry flag CY = 1<br></td>
                </tr>
                <tr>
                    <td><strong>JNC</strong><br></td>
                    <td>address<br></td>
                    <td>Used to jump if no carry flag (CY = 0)<br></td>
                </tr>
                <tr>
                    <td><strong>JE/JZ</strong><br></td>
                    <td>address<br></td>
                    <td>Used to jump if equal/zero flag ZF = 1<br></td>
                </tr>
                <tr>
                    <td><strong>JNE/JNZ</strong><br></td
                        ><td>address<br></td>
                        <td>Used to jump if not equal/zero flag ZF = 0<br></td>
                    </tr>
                    <tr>
                        <td><strong>JO</strong><br></td>
                        <td>address<br></td>
                        <td>Used to jump if overflow flag OF = 1<br></td>
                    </tr>
                    <tr>
                        <td><strong>JNO</strong><br></td>
                        <td>address<br></td>
                        <td>Used to jump if no overflow flag OF = 0<br></td>
                    </tr>
                    <tr>
                        <td><strong>JP/ JPE</strong><br></td>
                        <td>address<br></td>
                        <td>Used to jump if parity/parity even PF = 1<br></td>
                    </tr>
                    <tr>
                        <td><strong>JNP/ JPO</strong><br></td>
                        <td>address<br></td>
                        <td>Used to jump if not parity/parity odd PF = 0<br></td>
                    </tr>
                    <tr>
                        <td><strong>JS</strong><br></td>
                        <td>address<br></td>
                        <td>Used to jump if sign flag SF = 1<br></td>
                    </tr>
                    <tr>
                        <td><strong>JNS</strong><br></td>
                        <td>address<br></td>
                        <td>Used to jump if not sign SF = 0<br></td>
                    </tr>
                    <tr>
                        <td><strong>JA/ JNBE</strong><br></td>
                        <td>address<br></td>
                        <td>Used to jump if above/not below/equal instruction satisfies.<br></td>
                    </tr>
                    <tr>
                        <td><strong>JAE/ JNB</strong><br></td>
                        <td>address<br></td>
                        <td>Used to jump if above/not below instruction satisfies.<br></td>
                    </tr>
                    <tr>
                        <td><strong>JBE/ JNA</strong><br></td>
                        <td>address<br></td>
                        <td>Used to jump if below/equal/ not above instruction satisfies.<br></td>
                    </tr>
                    <tr>
                        <td><strong>JG/ JNLE</strong><br></td>
                        <td>address<br></td>
                        <td>Used to jump if greater/not less than/equal instruction satisfies.<br></td>
                    </tr>
                    <tr>
                        <td><strong>JGE/ JNL</strong><br></td>
                        <td>address<br></td>
                        <td>Used to jump if greater than/equal/not less than instruction satisfies.<br></td>
                    </tr>
                    <tr>
                        <td><strong>JL/ JNGE</strong><br></td>
                        <td>address<br></td>
                        <td>Used to jump if less than/not greater than/equal instruction satisfies.<br></td>
                    </tr>
                    <tr>
                        <td><strong>JLE/ JNG</strong><br></td>
                        <td>address<br></td>
                        <td>Used to jump if less than/equal/if not greater than instruction satisfies.<br></td>
                    </tr>
                    <tr>
                        <td><strong>JCXZ</strong><br></td>
                        <td>address<br></td>
                        <td>Used to jump to the provided address if CX = 0<br></td>
                    </tr>
                    <tr>
                        <td><strong>LOOPE/ LOOPZ</strong><br></td>
                        <td>address<br></td>
                        <td>Used to loop a group of instructions till it satisfies ZF = 1 &amp; CX = 0<br></td>
                    </tr>
                    <tr>
                        <td><strong>LOOPNE/ LOOPNZ</strong><br></td>
                        <td>address<br></td>
                        <td>Used to loop a group of instructions till it satisfies ZF = 0 &amp; CX = 0<br></td>
                    </tr>
                </tbody>
            </table>

    </article>
    <!-- BRANCH INSTRUCTION ENDS -->
    <br>

    <!-- Iteration Control Instruction start -->
    <article>
        <h3 id="itrn_ctl_inst">Iteration Control Instruction</h3>
        <p>These instructions are used to execute the given instructions for number of times. Following is the list of instructions under this group</p>
        <ul>
            <li><strong>LOOP</strong> − Used to loop a group of instructions until the condition satisfies, i.e., CX = 0</li>
            <li><strong>LOOPE/LOOPZ </strong>− Used to loop a group of instructions till it satisfies ZF = 1 & CX = 0</li>
            <li><strong>LOOPNE/LOOPNZ</strong>− Used to loop a group of instructions till it satisfies ZF = 0 & CX = 0</li>
            <li><strong>JCXZ</strong>− Used to jump to the provided address if CX = 0</li>
        </ul>
    </article>
    <!-- Iteration Control Instruction start -->

    <!-- Processor Control / machine Control Instruction start -->
    <article>
        <h3 id="p/m_con_inst">Processor Control / machine Control Instruction</h3>
        <p>These instructions are used to control the processor action by setting/resetting the flag values</p>
        <p>Following are the instructions under this group </p>
        <ul>
            <li>STC − Used to set carry flag CF to 1</li>
            <li>CLC − Used to clear/reset carry flag CF to 0</li>
            <li>CMC − Used to put complement at the state of carry flag CF.</li>
            <li>STD − Used to set the direction flag DF to 1</li>
            <li>CLD − Used to clear/reset the direction flag DF to 0</li>
            <li>STI − Used to set the interrupt enable flag to 1, i.e., enable INTR input.</li>
            <li>CLI − Used to clear the interrupt enable flag to 0, i.e., disable INTR input.</li>
        </ul>
    </article>
    <!-- Processor Control / machine Control Instruction Ends -->
    <br>

    <!-- External Hardware Synchronization Instruction start -->
    <article>
        <h3 id="exl_hwe_syn_inst">External Hardware Synchronization Instruction</h3>
        <p>The 8086 External Hardware Synchronization Instructions are namely</p>
        <ol>
            <li>
                <h5>HLT Instruction :</h5>
                <p>The HLT instruction will cause the 8086 to stop fetching and executing instructions. The 8086 will enter a halt state. The only ways to get the processor out of the halt state are with an interrupt signal on the INTR pin, an interrupt signal on the NMI pin, or a reset signal on the RESET input.</p>
                
            </li>
            <li>
                <h5>WAIT Instruction :</h5>
                <p>When this instruction executes, the 8086 enters an idle condition where it is doing no processing. The 8086 will stay in this idle state until a signal is asserted on the 8086 TEST input pin, or until a valid interrupt signal is received on the INTR or the NMI interrupt input pins. If a valid interrupt occurs while the 8086 is in this idle state, the 8086 will return to the idle state after the execution of interrupt service procedure. WAIT affects, no flags. The WAIT, instruction is used to synchronize the 8086 with 8086 External Hardware Synchronization Instructions such as the 8087 math coprocessor.</p>
            </li>
            <li>
                <h5>ESC Instruction :</h5>
                <p>This instruction is used to pass instructions to a coprocessor such as the 8087 math coprocessor which shares the address and data bus with an 8086. Instructions for the coprocessor are represented by a 6-bit code embedded in the escape instruction. When the 8086 fetches an ESC instruction, the coprocessor decodes the instruction and carries out the action specified by the 6-bit code specified in the instruction. In most cases the 8086 treats the ESC instruction as a NOP. In some cases the 8086 will access a data item in memory for the coprocessor.</p>
            </li>
            <li>
                <h5>LOCK Instruction :</h5>
                <p>In a multiprocessor system each microprocessor has its own local’ buses and memory. The individual microprocessors are connected together by a system bus so that each can access system resources such as disk drives , or, memory. Each microprocessor only takes control of the system bus when it needs to access some system resources. The LOCK prefix allows a microprocessor to make sure that another processor does not take control of the system bus while it is in the middle of a critical instruction which uses the system bus. The LOCK prefix is put in front of the critical instruction. When an instruction with a LOCK prefix executes, the 8086 will assert its bus lock signal output. This signal is connected to an 8086 External Hardware Synchronization Instructions bus controller device which then prevents any other processor from taking over the system bus. LOCK affects no flags.</p>
            </li>
            <li>
                <h5>NOP Instruction :</h5>
                <p>At the time of execution of NOP instruction, no operation is performed except fetch and decode. It takes three clock cycles to execute the instruction. NOP instruction does not affect any flag. This instruction is used to fill in time delays or to delete and insert instructions in the program while trouble shooting.</p>
            </li>
        </ol>
    </article>
    <!-- External Hardware Synchronization Instruction end -->
    <br>

    <!-- Interrupt Control Instruction start -->
    <article>
        <h3 id="itr_clt_inst">Interrupt Control Instruction</h3>
        <p>These instructions are used to call the interrupt during program execution.</p>
        <ul>
            <li>INT − Used to interrupt the program during execution and calling service specified</li>
            <li>INTO − Used to interrupt the program during execution if OF = 1</li>
            <li>IRET − Used to return from interrupt service to the main program</li>
        </ul>

    </article>
    <!-- Interrupt Control Instruction end -->
    <br>

    <!-- String Instruction of 8086 start -->
    <article>
        <h3 id="str_inst">String Instruction of 8086</h3>
        <p>String is a group of bytes/words and their memory is always allocated in a sequential order.</p>
        <p>Following is the list of instructions under this group </p>
        <ul>
            <li>REP − Used to repeat the given instruction till CX ≠ 0.</li>
            <li>REPE/REPZ − Used to repeat the given instruction until CX = 0 or zero flag ZF = 1</li>
            <li>REPNE/REPNZ − Used to repeat the given instruction until CX = 0 or zero flag ZF = 1.</li>
            <li>MOVS/MOVSB/MOVSW − Used to move the byte/word from one string to another</li>
            <li>COMS/COMPSB/COMPSW − Used to compare two string bytes/words</li>
            <li>INS/INSB/INSW − Used as an input string/byte/word from the I/O port to the provided memory location</li>
            <li>OUTS/OUTSB/OUTSW − Used as an output string/byte/word from the provided memory location to the I/O port</li>
            <li>SCAS/SCASB/SCASW − Used to scan a string and compare its byte with a byte in AL or string word with a word in AX.</li>
            <li>LODS/LODSB/LODSW − Used to store the string byte into AL or string word into AX.</li>
        </ul>
    </article>
    <!-- String Instruction of 8086 end -->
    <br>
    
    <!-- 8086 Instruction Template/Format start -->
    <article>
        <h3 id="inst_temp">8086 Instruction Template/Format</h3>
        <p>For every instruction that is executed in the 8086 microprocessor, an instruction format is available that is the binary representation of that instruction.</p>
        <p>This instruction format can be coded from 1 to 6 bytes depending upon the addressing modes used for instructions</p>
        <p>The general Instruction format that most of the instructions of the 8086 microprocessor follow is:</p>
        <img src="{% static 'mp_img/ch2_inst_fmt.jpg' %}" alt="">
        <br>
        <ul>
            <li>The Opcode stands for Operation Code. Every Instruction has a unique 6-bit opcode. For example, the opcode for MOV is 100010.</li>
            <li>
                <p>D stands for direction</p>
                <p>If D=0, then the direction is from the register</p>
                <p>If D=1, then the direction is to the register</p>
            </li>
            <li>
                <p>W stands for word</p>
                <p>If W=0, then only a byte is being transferred, i.e. 8 bits</p>
                <p>If W=1, them a whole word is being transferred, i.e. 16 bits</p>
            </li>
            <li>The MOD and R/M together is calculated based upon the addressing mode and register being used in it. This is calculated as follows:</li>
            <table >
                <tr>
                    <th>R/M </th>
                    <th>0 0<br />(Memory Mode with no displacement)</th>
                    <th>0 1<br />(Memory mode with 8 bit displacement)</th>
                    <th>1 0<br />(Memory Mode with 16 bit displacement)</th>
                    <th>1 1<br />(Register Mode)</th>
                </tr>
                <tr>
                    <td>000</td>
                    <td>[BX] + [SI]</td>
                    <td>[BX] + [SI] + d8</td>
                    <td>[BX] + [SI] + d16</td>
                    <td>AL AX</td>
                </tr>
                <tr>
                    <td>001</td>
                    <td>[BX] + [DI]</td>
                    <td>[BX] + [DI] + d8</td>
                    <td>[BX] + [DI] + d16</td>
                    <td>CL CX</td>
                </tr>
                <tr>
                <td>010</td><td>[BP] + [SI]</td><td>[BP] + [SI] + d8</td><td>[BP] + [SI] + d16</td><td>DL DX</td>
                </tr>
                <tr>
                <td>011</td><td>[BP] + [DI]</td><td>[BP] + [DI] + d8</td><td>[BP] + [DI] + d16</td><td>BL BX</td>
                </tr>
                <tr>
                <td>100</td><td>[SI]</td><td>[SI] + d8</td><td>[SI] + d16</td><td>AH SP</td>
                </tr>
                <tr>
                <td>101</td><td>[DI]</td><td>[DI] + d8</td><td>[DI] + d16</td><td>CH BP</td>
                </tr>
                <tr>
                <td>110</td><td>d16 (direct)</td><td>[BP] + d8</td><td>[BP] + d16</td><td>DH SI</td>
                </tr>
                <tr>
                <td>111</td><td>[BX]</td><td>[BX] + d8</td><td>[BX] + d16</td><td>BH DI</td>
                </tr>
            </table>
            <li><li>REG stands for register selected. It is a 3-bit code which is calculated as follows:</li></li>
            <table >
                <tr>
                <th>REG Code</th>
                <th>Register Selected</th>
                </tr>
                <tr>
                <td>0 0 0</td><td>AL AX</td>
                </tr>
                <tr>
                <td>0 0 1</td><td>CL CX</td>
                </tr>
                <tr>
                <td>0 1 0</td><td>DL DX</td>
                </tr>
                <tr>
                <td>0 1 1 </td><td>BL BX</td>
                </tr>
                <tr>
                <td>1 0 0</td><td>AH SP</td>
                </tr>
                <tr>
                <td>1 0 1</td><td>CH BP</td>
                </tr>
                <tr>
                <td>1 1 0</td><td>DH SI</td>
                </tr>
                <tr>
                <td>1 1 1 </td><td>BH DI</td>
                </tr>
            </table>
            <li><li>The low order displacement and high order displacement are optional and the instruction format contains them only if there exists any displacement in the instruction. If the displacement is of 8 bits, then only the cell of low order displacement infilled and if the displacement is of 16 bits, then both the cells od low order and high order are filled, with the exact bits that the displacement number represents.</li></li>
        </ul>
    </article>
    <!-- 8086 Instruction Template/Format end  -->
    <br>

    <!-- 8086 Assembler Directive, Pseudo Opcodes start -->
    <article>
        <h3 id="amlr_dir_psd_opcd">8086 Assembler Directive, Pseudo Opcodes</h3>
        <p>Assembly language has 2 types of statements :</p>
        <p>1. Executable : Instructions that are translated into Machine Code by the assembler.</p>
        <p>2 Assembler Directives :</p>
        <ul>
            <li>Statements that direct the assembler to do some special task.</li>
            <li>No M/C language code is produced for these statements</li>
            <li>Their main task is to inform the assembler about the start/end of a segment, procedure or program, to reserve appropriate space for data storage etc. </li>
            <li>Some of the assembler directives are listed below: </li>
            <ol>
                <li>
                    <p>DB (Define Byte) Used to define a Byte type variable.</p>
                    <p>Eg.: SUM DBO Assembler reserves 1 Byte of memory for the variable</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;named SUM and initialize it to 0.</p>
                </li>
                <li>
                    <p>DW (Define Word) Used to define a Word type variable (2 Bytes)</p>
                </li>
                <li>DD (Double Word) ; Used to define a Double Word type variable (4 Bytes).</li>
                <li>DD (Double Word) ; Used to define a Double Word type variable (4 Bytes). </li>
                <li>DQ (Quad Word) Used to define a Quad Word type variable (8 Bytes). </li>
                <li>DT (Ten Bytes) Used to define 10 Bytes to a variable (10 Bytes). </li>
                <li>DUP()  ;  Copies the contents of the bracket followed by this</li>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyword into the memory location specified before it.</p>
                <li>SEGMENT ;   Used to indicate the beginning of a segment. </li>
                <li>ENDS    ; Used to indicate the end of a segment</li>
                <li>ASSUME    ; Associates a logical segment with a processor segment.</li>
                <li>PROC    ;    Used to indicate the beginning of a procedure.</li>
                <li>ENDP    ;    Used to indicate the end of a procedure.</li>
                <li>END     ;    Used to indicate the end of a program.</li>
                <li>EQU     ;   Defines a constant</li>
                <br>

                <p>Do remember, in the class, you have been clearly made to understand the difference between using a variable and using a constant </p>
                <li>EVEN / ALIGN    ; Ensures that the data will be stored by the assembler in the memory in an aligned form. Aligned data works faster as it can be accessed in one cycle. Misaligned data, though is valid, requires two cycles
                                   to be accessed hence works slower.
                </li>
            </ol>
        </ul>
    </article>
    <!-- 8086 Assembler Directive, Pseudo Opcodes end -->
    <br>    
</section>
<!-- CHAPTER 2 END -->


<br>





{% endblock main %}
